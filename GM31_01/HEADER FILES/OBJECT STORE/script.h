#pragma once
#include "../saveFunctions.h"

#define COLLIDE_COUNTDOWN (5.0f / FRAME_RATE)
#define SPRING_NUMS	(TILES*(TILES + 1) + TILES*(TILES + 1) + TILES*TILES * 2)	// スプリング総数

class PlayerMovement : public Script
{
public:
	enum PLAYER_STATE
	{
		NORMAL_MOVE_PS,
		AIMING_MOVE_PS,
		ROLL_PS,

		PS_MAX
	};
	bool move;
	bool diagonal;
	bool aim;
	bool gunSelection;

	int idleCounter;

	D3DXVECTOR3 rotationDirection;
	D3DXVECTOR3 direction;
	
	D3DXVECTOR3* aimPoint;

private:
	bool setAnimation;

	PLAYER_STATE playerState;

public:

	void Start() override;
	void End() override;
	void Update() override;
	void Draw() override;

	void EngineDisplay() override;

	void NormalMove();
	void AimingMove();
	void Roll();
};
class Ground : public Script
{
public:
	void Start() override;
	void End() override;
	void Update() override;
	void Draw() override;

	void EngineDisplay() override;
};
class EnemyScript : public Script
{
private:

public:

	void Start() override;
	void End() override;
	void Update() override;
	void Draw() override;

	void EngineDisplay() override;
};
class BulletScript : public Script
{
private:

public:

	void Start() override;
	void Update() override;

	void EngineDisplay() override;

	void OnCollisionEnter(GAMEOBJECT* obj) override;

};
class HitPoints : public Script
{
private:
	bool disable;
	bool invincible;
	bool noDamage;

	float hp;
	float* barController;

	GAMEOBJECT* object;

public:

	void Start() override;
	void End() override;
	void Update() override;
	void Draw() override;

	void EngineDisplay() override;

	float GetHP() { return hp; }
	bool GetNoDamage() { return noDamage; }
	bool GetInvincible() { return invincible; }

	void SetDisable(bool value) { disable = value; }
	void SetHP(float value) { hp = value; }
	void SetBarController(float* value) { barController = value; }
	void SetObject(GAMEOBJECT* value) { object = value; }

	void Invincible() { noDamage = true; invincible = true; }
	void Vulnerable() { noDamage = false; invincible = false; }

	bool Damage(float damage = 1.0f);
	void Heal(float value = 1.0f);
};
class PlayerControl : public Script
{
private:

public:

	void Start() override;
	void End() override;
	void Update() override;
	void Draw() override;

	void EngineDisplay() override;

private:
	void Spawn();
};
class GameManager : public Script
{
private:
	GAMEOBJECT* Player;
	float slowMotionSpeed;

public:

	void Start() override;
	void End() override;
	void Update() override;
	void Draw() override;

	void EngineDisplay() override;

};
class ClothSimulator : public Script
{
public:
	struct WINDFORCE {
		int			status;				// ステータス
		D3DXVECTOR3	force;				// 風力ベクトル
	};
	struct Particle {
		bool	onLock;				// 固定フラグ
		bool	onDrag;				// マウスドラッグ中判定フラグ
		D3DXVECTOR3	position;			// 位置座標 (Position)
		D3DXVECTOR3	velocity;			// 速度 (Velocity)
		D3DXVECTOR3	acceleration;		// 加速度 (Acceleration)
		D3DXVECTOR3	resultant;			// 合力 (Resultant)
		D3DXVECTOR3	gravity;			// 重力 (Gravity)
	};
	struct P_REF {
		int		horz;				// 横方向インデックス
		int		vert;				// 縦方向インデックス
	};
	struct Spring {
		P_REF	p1;					// 接続されている粒子１
		P_REF	p2;					// 接続されている粒子２
		float	length;				// 自然長
	};
	struct CLOTH {
		int			status;														// ステータス
		Particle	particle[TILES + 1][TILES + 1];		// 構成粒子
		Spring		Spring[SPRING_NUMS];										// 粒子間のバネ
	};

public:
	int num;
	MeshField* mesh;
	CLOTH cloth;
	WINDFORCE	windForce;

public:

	void Start() override;
	void End() override;
	void Update() override;
	void Draw() override;

	void EngineDisplay() override;

	void WindForce();
	void ClothSimulation();
};
class ArtificialIntelligence : public Script
{
public:

	enum ENEMY_STATE
	{
		ROAM,
		FOLLOW,
		WAIT,
		ATTACK,
		FIND,
		RETURN,

		ENEMY_STATE_MAX
	};

private:
	bool flip;
	bool lock;

	int index;
	int nextIndex;

	float distance;

	D3DXVECTOR3 startPosition;
	D3DXVECTOR3 returnPosition;

	ENEMY_STATE state;

	Projector* projector;
	MeshFilter* model;
	GAMEOBJECT* target;
	GAMEOBJECT* seeker;

	std::string targetName;
	std::vector<GAMEOBJECT*> points;

public:

	void Start() override;
	void End() override;
	void Update() override;
	void Draw() override;

	void EngineDisplay() override;
	void OnCollisionEnter(GAMEOBJECT* obj) override;

	void Roam();
	void Follow();
	void Return();
	void Wait();
	void Attack();
	void Find();

	void Finder();
};
class ScreenToWorld : public Script
{
private:
	D3DXVECTOR3 worldPosition;
	GAMEOBJECT* point;

public:

	void Start() override;
	void End() override;
	void Update() override;
	void Draw() override;

	void EngineDisplay() override;

	D3DXVECTOR3* CalcScreenToWorld(
		D3DXVECTOR3* pout,
		int Sx,  // スクリーンX座標
		int Sy,  // スクリーンY座標
		float fZ,  // 射影空間でのZ値（0〜1）
		int Screen_w,
		int Screen_h,
		D3DXMATRIX* View,
		D3DXMATRIX* Prj
	);

	D3DXVECTOR3* CalcScreenToXZ(
		D3DXVECTOR3* pout,
		int Sx,
		int Sy,
		int Screen_w,
		int Screen_h,
		D3DXMATRIX* View,
		D3DXMATRIX* Prj
	);

	D3DXVECTOR3* GetPoint() { return &point->transform->Position; }
};

//Camera Scripts
class CameraScript : public Script
{
protected:
	Camera* camera;

public:

	void Start() { camera = gameObject->GetComponent<Camera>(); }

};
class TopDownCamera : public CameraScript
{
private:

public:

	void Update() override;

	void EngineDisplay() override;

};
class ThirdPersonCamera : public CameraScript
{
private:

public:

	void Update() override;

	void EngineDisplay() override;

};
class FirstPersonCamera : public CameraScript
{
private:

public:

	void Update() override;

	void EngineDisplay() override;

};
class OpenWorldCamera : public CameraScript
{
private:

public:

	void Update() override;

	void EngineDisplay() override;

};
class RevolutionCamera : public CameraScript
{
private:
	float offsetSpeed = 0.02f;
	D3DXVECTOR3 targetOffset = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

public:

	void Update() override;

	void EngineDisplay() override;

};